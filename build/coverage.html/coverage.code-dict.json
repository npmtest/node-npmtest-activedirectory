{"/home/travis/build/npmtest/node-npmtest-activedirectory/test.js":"/* istanbul instrument in package npmtest_activedirectory */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-activedirectory/lib.npmtest_activedirectory.js":"/* istanbul instrument in package npmtest_activedirectory */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_activedirectory = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_activedirectory = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-activedirectory/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-activedirectory && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_activedirectory */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_activedirectory\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_activedirectory.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_activedirectory.rollup.js'] =\n            local.assetsDict['/assets.npmtest_activedirectory.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_activedirectory.__dirname + '/lib.npmtest_activedirectory.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-activedirectory/node_modules/activedirectory/index.js":"module.exports = require('./lib/activedirectory');","/home/travis/build/npmtest/node-npmtest-activedirectory/node_modules/activedirectory/lib/activedirectory.js":"var events = require('events');\nvar util = require('util');\nvar ldap = require('ldapjs');\nvar async = require('async');\nvar _ = require('underscore');\nvar bunyan = require('bunyan');\nvar Url = require('url');\n\nvar User = require('./models/user');\nvar Group = require('./models/group');\nvar RangeRetrievalSpecifierAttribute = require('./client/rangeretrievalspecifierattribute');\n\nvar isPasswordLoggingEnabled = false;\nvar maxOutputLength = 256;\n\nvar log = bunyan.createLogger({\n  name: 'ActiveDirectory',\n  streams: [\n    { level: 'fatal',\n      stream: process.stdout }\n  ]\n});\n\nvar defaultPageSize = 1000; // The maximum number of results that AD will return in a single call. Default=1000\nvar defaultAttributes, originalDefaultAttributes;\ndefaultAttributes = originalDefaultAttributes = {\n  user: [ \n    'dn',\n    'userPrincipalName', 'sAMAccountName', /*'objectSID',*/ 'mail',\n    'lockoutTime', 'whenCreated', 'pwdLastSet', 'userAccountControl',\n    'employeeID', 'sn', 'givenName', 'initials', 'cn', 'displayName',\n    'comment', 'description' \n  ],\n  group: [\n    'dn', 'cn', 'description'\n  ]\n};\n\nvar defaultReferrals, originalDefaultReferrals;\ndefaultReferrals = originalDefaultReferrals = {\n  enabled: false,\n  // Active directory returns the following partitions as default referrals which we don't want to follow\n  exclude: [\n    'ldaps?://ForestDnsZones\\\\..*/.*',\n    'ldaps?://DomainDnsZones\\\\..*/.*',\n    'ldaps?://.*/CN=Configuration,.*'\n  ]\n};\n\n// Precompile some common, frequently used regular expressions.\nvar re = {\n  'isDistinguishedName': /(([^=]+=.+),?)+/gi,\n  'isUserResult': /CN=Person,CN=Schema,CN=Configuration,.*/i,\n  'isGroupResult': /CN=Group,CN=Schema,CN=Configuration,.*/i\n};\n\n/**\n * Agent for retrieving ActiveDirectory user & group information.\n *\n * @public\n * @constructor\n * @param {Object|String} url The url of the ldap server (i.e. ldap://domain.com). Optionally, all of the parameters can be specified as an object. { url: 'ldap://domain.com', baseDN: 'dc=domain,dc=com', username: 'admin@domain.com', password: 'supersecret', { referrals: { enabled: true }, attributes: { user: [ 'attributes to include in response' ], group: [ 'attributes to include in response' ] } } }. 'attributes' & 'referrals' parameter is optional and only necesary if overriding functionality.\n * @param {String} baseDN The default base container where all LDAP queries originate from. (i.e. dc=domain,dc=com)\n * @param {String} username The administrative username or dn of the user for retrieving user & group information. (i.e. Must be a DN or a userPrincipalName (email))\n * @param {String} password The administrative password of the specified user.\n * @param {Object} defaults Allow for default options to be overridden. { attributes: { user: [ 'attributes to include in response' ], group: [ 'attributes to include in response' ] } }\n * @returns {ActiveDirectory}\n */\nvar ActiveDirectory = function(url, baseDN, username, password, defaults) {\n  if (this instanceof ActiveDirectory) {\n    this.opts = {};\n    if (typeof(url) === 'string') {\n      this.opts.url = url;\n      this.baseDN = baseDN;\n      this.opts.bindDN = username;\n      this.opts.bindCredentials = password;\n\n      if (typeof((defaults || {}).entryParser) === 'function') {\n        this.opts.entryParser = defaults.entryParser;\n      }\n    }\n    else {\n      this.opts = _.defaults({}, url);\n      this.baseDN = this.opts.baseDN;\n\n      if (! this.opts.bindDN) this.opts.bindDN = this.opts.username;\n      if (! this.opts.bindCredentials) this.opts.bindCredentials = this.opts.password;\n\n      if (this.opts.logging) {\n        log = bunyan.createLogger(_.defaults({}, this.opts.logging));\n        delete(this.opts.logging);\n      }\n    }\n\n    defaultAttributes = _.extend({}, originalDefaultAttributes, (this.opts || {}).attributes || {}, (defaults || {}).attributes || {});\n    defaultReferrals = _.extend({}, originalDefaultReferrals, (this.opts || {}).referrals || {}, (defaults || {}).referrals  || {});\n\n    log.info('Using username/password (%s/%s) to bind to ActiveDirectory (%s).', this.opts.bindDN,\n             isPasswordLoggingEnabled ? this.opts.bindCredentials : '********', this.opts.url);\n    log.info('Referrals are %s', defaultReferrals.enabled ? 'enabled. Exclusions: '+JSON.stringify(defaultReferrals.exclude): 'disabled');\n    log.info('Default user attributes: %j', defaultAttributes.user || []);\n    log.info('Default group attributes: %j', defaultAttributes.group || []);\n\n    // Enable connection pooling\n    // TODO: To be disabled / removed in future release of ldapjs > 0.7.1\n    if (typeof(this.opts.maxConnections) === 'undefined') {\n      this.opts.maxConnections = 20;\n    }\n    events.EventEmitter.call(this);\n  }\n  else {\n    return(new ActiveDirectory(url, baseDN, username, password, defaults));\n  }\n};\nutil.inherits(ActiveDirectory, events.EventEmitter);\n\n/**\n * Expose ldapjs filters to avoid TypeErrors for filters\n * @static\n */\nActiveDirectory.filters = ldap.filters;\n\n/**\n * Truncates the specified output to the specified length if exceeded.\n * @param {String} output The output to truncate if too long\n * @param {Number} [maxLength] The maximum length. If not specified, then the global value maxOutputLength is used.\n */\nfunction truncateLogOutput(output, maxLength) {\n  if (typeof(maxLength) === 'undefined') maxLength = maxOutputLength;\n  if (! output) return(output);\n\n  if (typeof(output) !== 'string') output = output.toString();\n  var length = output.length;\n  if ((! length) || (length < (maxLength + 3))) return(output);\n\n  var prefix = Math.ceil((maxLength - 3)/2);\n  var suffix = Math.floor((maxLength - 3)/2);\n  return(output.slice(0, prefix)+ '...' +\n    output.slice(length-suffix));\n}\n\n/**\n * Checks to see if there are any event emitters defined for the\n * specified event name.\n * @param {String} event The name of the event to inspect.\n * @returns {Boolean} True if there are events defined, false if otherwise.\n */\nfunction hasEvents(event) {\n  return(events.EventEmitter.listenerCount(this, event) > 0);\n}\n\n/**\n * Checks to see if the value is a distinguished name.\n *\n * @private\n * @param {String} value The value to check to see if it's a distinguished name.\n * @returns {Boolean}\n */\nfunction isDistinguishedName(value) {\n  log.trace('isDistinguishedName(%s)', value);\n  if ((! value) || (value.length === 0)) return(false);\n  re.isDistinguishedName.lastIndex = 0; // Reset the regular expression\n  return(re.isDistinguishedName.test(value));\n}\n\n/**\n * Parses the distinguishedName (dn) to remove any invalid characters or to\n * properly escape the request.\n *\n * @private\n *   @param dn {String} The dn to parse.\n * @returns {String}\n */\nfunction parseDistinguishedName(dn) {\n  log.trace('parseDistinguishedName(%s)', dn);\n  if (! dn) return(dn);\n\n  dn = dn.replace(/\"/g, '\\\\\"');\n  return(dn.replace('\\\\,', '\\\\\\\\,'));\n}\n\n/**\n * Gets the ActiveDirectory LDAP query string for a user search.\n *\n * @private\n * @param {String} username The samAccountName or userPrincipalName (email) of the user.\n * @returns {String}\n */\nfunction getUserQueryFilter(username) {\n  log.trace('getUserQueryFilter(%s)', username);\n  var self = this;\n\n  if (! username) return('(objectCategory=User)');\n  if (isDistinguishedName.call(self, username)) {\n    return('(&(objectCategory=User)(distinguishedName='+parseDistinguishedName(username)+'))');\n  }\n\n  return('(&(objectCategory=User)(|(sAMAccountName='+username+')(userPrincipalName='+username+')))');\n}\n\n/**\n * Gets a properly formatted LDAP compound filter. This is a very simple approach to ensure that the LDAP\n * compound filter is wrapped with an enclosing () if necessary. It does not handle parsing of an existing\n * compound ldap filter.\n * @param {String} filter The LDAP filter to inspect.\n * @returns {String}\n */\nfunction getCompoundFilter(filter) {\n  log.trace('getCompoundFilter(%s)', filter);\n\n  if (! filter) return(false);\n  if ((filter.charAt(0) === '(') && (filter.charAt(filter.length - 1) === ')')) {\n    return(filter);\n  }\n  return('('+filter+')');\n}\n\n/**\n * Gets the ActiveDirectory LDAP query string for a group search.\n *\n * @private\n * @param {String} groupName The name of the group\n * @returns {String}\n */\nfunction getGroupQueryFilter(groupName) {\n  log.trace('getGroupQueryFilter(%s)', groupName);\n  var self = this;\n\n  if (! groupName) return('(objectCategory=Group)');\n  if (isDistinguishedName.call(self, groupName)) {\n    return('(&(objectCategory=Group)(distinguishedName='+parseDistinguishedName(groupName)+'))');\n  }\n  return('(&(objectCategory=Group)(cn='+groupName+'))');\n}\n\n/**\n * Checks to see if the LDAP result describes a group entry.\n * @param {Object} item The LDAP result to inspect.\n * @returns {Boolean}\n */\nfunction isGroupResult(item) {\n  log.trace('isGroupResult(%j)', item);\n\n  if (! item) return(false);\n  if (item.groupType) return(true);\n  if (item.objectCategory) {\n    re.isGroupResult.lastIndex = 0; // Reset the regular expression\n    return(re.isGroupResult.test(item.objectCategory));\n  }\n  if ((item.objectClass) && (item.objectClass.length > 0)) {\n    return(_.any(item.objectClass, function(c) { return(c.toLowerCase() === 'group'); }));\n  }\n  return(false);\n}\n\n/**\n * Checks to see if the LDAP result describes a user entry.\n * @param {Object} item The LDAP result to inspect.\n * @returns {Boolean}\n */\nfunction isUserResult(item) {\n  log.trace('isUserResult(%j)', item);\n\n  if (! item) return(false);\n  if (item.userPrincipalName) return(true);\n  if (item.objectCategory) {\n    re.isUserResult.lastIndex = 0; // Reset the regular expression\n    return(re.isUserResult.test(item.objectCategory));\n  }\n  if ((item.objectClass) && (item.objectClass.length > 0)) {\n    return(_.any(item.objectClass, function(c) { return(c.toLowerCase() === 'user'); }));\n  }\n  return(false);\n}\n\n/**\n * Factory to create the LDAP client object.\n *\n * @private\n * @param {String} url The url to use when creating the LDAP client.\n * @param {object} opts The optional LDAP client options.\n */\nfunction createClient(url, opts) {\n  // Attempt to get Url from this instance.\n  url = url || this.url || (this.opts || {}).url || (opts || {}).url;\n  if (! url) {\n    throw 'No url specified for ActiveDirectory client.';\n  }\n  log.trace('createClient(%s)', url);\n\n  var opts = getLdapClientOpts(_.defaults({}, { url: url }, opts, this.opts));\n  log.debug('Creating ldapjs client for %s. Opts: %j', opts.url, _.omit(opts, 'url', 'bindDN', 'bindCredentials'));\n  var client = ldap.createClient(opts);\n  return(client);\n}\n\n/**\n * Checks to see if the specified referral or \"chase\" is allowed.\n * @param {String} referral The referral to inspect.\n * @returns {Boolean} True if the referral should be followed, false if otherwise.\n */\nfunction isAllowedReferral(referral) {\n  log.trace('isAllowedReferral(%j)', referral);\n  if (! defaultReferrals.enabled) return(false);\n  if (! referral) return(false);\n\n  return(! _.any(defaultReferrals.exclude, function(exclusion) {\n    var re = new RegExp(exclusion, \"i\");\n    return(re.test(referral));\n  }));\n}\n\n/**\n * From the list of options, retrieves the ldapjs specific options.\n *\n * @param {Object} opts The opts to parse.\n * @returns {Object} The ldapjs opts.\n */\nfunction getLdapOpts(opts) {\n  return(_.defaults({}, getLdapClientOpts(opts), getLdapSearchOpts(opts)));\n}\n\n/**\n * From the list of options, retrieves the ldapjs client specific options.\n *\n * @param {Object} opts The opts to parse.\n * @returns {Object} The ldapjs opts.\n */\nfunction getLdapClientOpts(opts) {\n  return(_.pick(opts || {},\n    // Client\n    'url',\n    'host', 'port', 'secure', 'tlsOptions',\n    'socketPath', 'log', 'timeout', 'idleTimeout',\n    'reconnect', 'queue', 'queueSize', 'queueTimeout',\n    'queueDisable', 'bindDN', 'bindCredentials',\n    'maxConnections'\n  ));\n}\n\n/**\n * From the list of options, retrieves the ldapjs search specific options.\n *\n * @param {Object} opts The opts to parse.\n * @returns {Object} The ldapjs opts.\n */\nfunction getLdapSearchOpts(opts) {\n  return(_.pick(opts || {},\n    // Search\n    'filter', 'scope', 'attributes', 'controls',\n    'paged', 'sizeLimit', 'timeLimit', 'typesOnly',\n    'derefAliases'\n  ));\n}\n\n/**\n * Performs a search on the LDAP tree.\n * \n * @private\n * @param {String} [baseDN] The optional base directory where the LDAP query is to originate from. If not specified, then starts at the root.\n * @param {Object} [opts] LDAP query string parameters to execute. { scope: '', filter: '', attributes: [ '', '', ... ], sizeLimit: 0, timelimit: 0 }\n * @param {Function} callback The callback to execure when completed. callback(err: {Object}, results: {Array[Object]}})\n */\nfunction search(baseDN, opts, callback) {\n  var self = this;\n\n  if (typeof(opts) === 'function') {\n    callback = opts;\n    opts = baseDN;\n    baseDN = undefined;\n  }\n  if (typeof(baseDN) === 'object') {\n    opts = baseDN;\n    baseDN = undefined;\n  }\n  opts || (opts = {});\n  baseDN || (baseDN = opts.baseDN) || (baseDN = self.baseDN);\n  log.trace('search(%s,%j)', baseDN, opts);\n\n  var isDone = false;\n  var pendingReferrals = [];\n  var pendingRangeRetrievals = 0;\n  var client = createClient.call(self, null, opts);\n  client.on('error', onClientError);\n\n  /**\n   * Call to remove the specified referral client.\n   * @param {Object} client The referral client to remove.\n   */\n  function removeReferral(client) {\n    if (! client) return;\n\n    client.unbind();\n    var indexOf = pendingReferrals.indexOf(client);\n    if (indexOf >= 0) {\n      pendingReferrals.splice(indexOf, 1);\n    }\n  }\n\n  /**\n   * The default entry parser to use. Does not modifications.\n   * @params {Object} entry The original / raw ldapjs entry to augment\n   * @params {Function} callback The callback to execute when complete.\n   */\n  var entryParser = (opts || {}).entryParser || (self.opts || {}).entryParser || function onEntryParser(item, raw, callback) {\n    callback(item);\n  };\n\n  /**\n   * Occurs when a search entry is received. Cleans up the search entry and pushes it to the result set.\n   * @param {Object} entry The entry received.\n   */\n  function onSearchEntry(entry) {\n    log.trace('onSearchEntry(%j)', entry);\n    var result = entry.object;\n    delete result.controls; // Remove the controls array returned as part of the SearchEntry\n\n    // Some attributes can have range attributes (paging). Execute the query\n    // again to get additional items.\n    pendingRangeRetrievals++;\n    parseRangeAttributes.call(self, result, opts, function(err, item) {\n      pendingRangeRetrievals--;\n\n      if (err) item = entry.object;\n      entryParser(item, entry.raw, function(item) {\n        if (item) results.push(item);\n        if ((! pendingRangeRetrievals) && (isDone)) {\n          onSearchEnd();\n        }\n      });\n    });\n  }\n\n  /**\n   * Occurs when a search reference / referral is received. Follows the referral chase if\n   * enabled.\n   * @param {Object} ref The referral.\n   */\n  function onReferralChase(ref) {\n    var index = 0;\n    var referralUrl;\n    // Loop over the referrals received.\n    while (referralUrl = (ref.uris || [])[index++]) {\n      if (isAllowedReferral(referralUrl)) {\n        log.debug('Following LDAP referral chase at %s', referralUrl);\n        var referralClient = createClient.call(self, referralUrl, opts);\n        pendingReferrals.push(referralClient);\n\n        var referral = Url.parse(referralUrl);\n        var referralBaseDn = (referral.pathname || '/').substring(1);\n        referralClient.search(referralBaseDn, getLdapOpts(opts), controls, function(err, res) {\n          /**\n           * Occurs when a error is encountered with the referral client.\n           * @param {Object} err The error object or string.\n           */\n          function onReferralError(err) {\n            log.error(err, '[%s] An error occurred chasing the LDAP referral on %s (%j)',\n                     (err || {}).errno, referralBaseDn, opts);\n            removeReferral(referralClient);\n          }\n          // If the referral chase / search failed, fail silently.\n          if (err) {\n            onReferralError(err);\n            return;\n          }\n\n          res.on('searchEntry', onSearchEntry);\n          res.on('searchReference', onReferralChase);\n          res.on('error', onReferralError);\n          res.on('end', function(result) {\n            removeReferral(referralClient);\n            onSearchEnd();\n          });\n        });\n      }\n    }\n  }\n\n  /**\n   * Occurs when a client / search error occurs.\n   * @param {Object} err The error object or string.\n   * @param {Object} res The optional server response.\n   */\n  function onClientError(err, res) {\n    if ((err || {}).name === 'SizeLimitExceededError') {\n      onSearchEnd(res);\n      return;\n    }\n\n    client.unbind();\n    log.error(err, '[%s] An error occurred performing the requested LDAP search on %s (%j)',\n              (err || {}).errno || 'UNKNOWN', baseDN, opts);\n    if (callback) callback(err);\n  }\n\n  /**\n   * Occurs when a search results have all been processed.\n   * @param {Object} result\n   */\n  function onSearchEnd(result) {\n    if ((! pendingRangeRetrievals) && (pendingReferrals.length <= 0)) {\n      client.unbind();\n      log.info('Active directory search (%s) for \"%s\" returned %d entries.',\n               baseDN, truncateLogOutput(opts.filter),\n               (results || []).length);\n      if (callback) callback(null, results);\n    }\n  }\n\n  var results = [];\n  \n  var controls = opts.controls || (opts.controls = []);\n  // Add paging results control by default if not already added.\n  if (!_.any(controls, function(control) { return(control instanceof ldap.PagedResultsControl); })) {\n    log.debug('Adding PagedResultControl to search (%s) with filter \"%s\" for %j',\n              baseDN, truncateLogOutput(opts.filter), _.any(opts.attributes) ? opts.attributes : '[*]');\n    controls.push(new ldap.PagedResultsControl({ value: { size: defaultPageSize } }));\n  }\n  if (opts.includeDeleted) {\n    if (!_.any(controls, function(control) { return(control.type === '1.2.840.113556.1.4.417'); })) {\n      log.debug('Adding ShowDeletedOidControl(1.2.840.113556.1.4.417) to search (%s) with filter \"%s\" for %j',\n                baseDN, truncateLogOutput(opts.filter), _.any(opts.attributes) ? opts.attributes : '[*]');\n      controls.push(new ldap.Control({ type: '1.2.840.113556.1.4.417', criticality: true }));\n    }\n  }\n\n  log.debug('Querying active directory (%s) with filter \"%s\" for %j',\n            baseDN, truncateLogOutput(opts.filter), _.any(opts.attributes) ? opts.attributes : '[*]');\n  client.search(baseDN, getLdapOpts(opts), controls, function onSearch(err, res) {\n    if (err) {\n      if (callback) callback(err);\n      return;\n    }\n\n    res.on('searchEntry', onSearchEntry);\n    res.on('searchReference', onReferralChase);\n    res.on('error', function(err) { onClientError(err, res); });\n    res.on('end', function(result) {\n      isDone = true; // Flag that the primary query is complete\n      onSearchEnd(result);\n    });\n  });\n}\n\n/**\n * Handles any attributes that might have been returned with a range= specifier.\n *\n * @private\n * @param {Object} result The entry returned from the query.\n * @param {Object} opts The original LDAP query string parameters to execute. { scope: '', filter: '', attributes: [ '', '', ... ], sizeLimit: 0, timelimit: 0 }\n * @param {Function} callback The callback to execute when completed. callback(err: {Object}, result: {Object}})\n */\nfunction parseRangeAttributes(result, opts, callback) {\n  log.trace('parseRangeAttributes(%j,%j)', result, opts);\n  var self = this;\n\n  // Check to see if any of the result attributes have range= attributes.\n  // If not, return immediately.\n  if (! RangeRetrievalSpecifierAttribute.prototype.hasRangeAttributes(result)) {\n    callback(null, result);\n    return;\n  }\n\n  // Parse the range attributes that were provided. If the range attributes are null\n  // or indicate that the range is complete, return the result.\n  var rangeAttributes = RangeRetrievalSpecifierAttribute.prototype.getRangeAttributes(result);\n  if ((! rangeAttributes) || (rangeAttributes.length <= 0)) {\n    callback(null, result);\n    return;\n  }\n\n  // Parse each of the range attributes. Merge the range attributes into\n  // the properly named property.\n  var queryAttributes = [];\n  _.each(rangeAttributes, function(rangeAttribute, index) {\n    // Merge existing range into the properly named property.\n    if (! result[rangeAttribute.attributeName]) result[rangeAttribute.attributeName] = [];\n    Array.prototype.push.apply(result[rangeAttribute.attributeName], result[rangeAttribute.toString()]);\n    delete(result[rangeAttribute.toString()]);\n\n    // Build our ldap query attributes with the proper attribute;range= tags to\n    // get the next sequence of data.\n    var queryAttribute = rangeAttribute.next();\n    if ((queryAttribute) && (! queryAttribute.isComplete())) {\n      queryAttributes.push(queryAttribute.toString());\n    }\n  });\n\n  // If we're at the end of the range (i.e. all items retrieved), return the result.\n  if (queryAttributes.length <= 0) {\n    log.debug('All attribute ranges %j retrieved for %s', rangeAttributes, result.dn);\n    callback(null, result);\n    return;\n  }\n\n  log.debug('Attribute range retrieval specifiers %j found for \"%s\". Next range: %j',\n            rangeAttributes, result.dn, queryAttributes);\n  // Execute the query again with the query attributes updated.\n  opts = _.defaults({ filter: '(distinguishedName='+parseDistinguishedName(result.dn)+')',\n                      attributes: queryAttributes }, opts);\n  search.call(self, opts, function onSearch(err, results) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    // Should be only one result\n    var item = (results || [])[0];\n    for(var property in item) {\n      if (item.hasOwnProperty(property)) {\n        if (! result[property]) result[property] = [];\n        if (_.isArray(result[property])) {\n          Array.prototype.push.apply(result[property], item[property]);\n        }\n      }\n    }\n    callback(null, result);\n  });\n}\n\n/**\n * Checks to see if any of the specified attributes are the wildcard\n * '*\" attribute.\n * @private\n * @params {Array} attributes - The attributes to inspect.\n * @returns {Boolean}\n */\nfunction shouldIncludeAllAttributes(attributes) {\n  return((typeof(attributes) !== 'undefined') &&\n         ((attributes.length === 0) ||\n          _.any(attributes || [], function(attribute) {\n           return(attribute === '*');\n         }))\n  );\n}\n\n/**\n * Gets the required ldap attributes for group related queries in order to\n * do recursive queries, etc.\n *\n * @private\n * @params {Object} [opts] Optional LDAP query string parameters to execute. { scope: '', filter: '', attributes: [ '', '', ... ], sizeLimit: 0, timelimit: 0 }\n */\nfunction getRequiredLdapAttributesForGroup(opts) {\n  if (shouldIncludeAllAttributes((opts || {}).attributes)) {\n    return([ ]);\n  }\n  return(_.union([ 'dn', 'objectCategory', 'groupType', 'cn' ], \n                 includeGroupMembershipFor(opts, 'group') ? [ 'member' ] : []));\n}\n\n/**\n * Gets the required ldap attributes for user related queries in order to\n * do recursive queries, etc.\n *\n * @private\n * @params {Object} [opts] Optional LDAP query string parameters to execute. { scope: '', filter: '', attributes: [ '', '', ... ], sizeLimit: 0, timelimit: 0 }\n */\nfunction getRequiredLdapAttributesForUser(opts) {\n  if (shouldIncludeAllAttributes((opts || {}).attributes)) {\n    return([ ]);\n  }\n  return(_.union([ 'dn', 'cn' ], \n                 includeGroupMembershipFor(opts, 'user') ? [ 'member' ] : []));\n}\n\n/**\n * Retrieves / merges the attributes for the query.\n */\nfunction joinAttributes() {\n  for (var index = 0, length = arguments.length; index < length; index++){\n    if (shouldIncludeAllAttributes(arguments[index])) {\n      return([ ]);\n    }\n  }\n  return(_.union.apply(this, arguments));\n}\n\n/**\n * Picks only the requested attributes from the ldap result. If a wildcard or\n * empty result is specified, then all attributes are returned.\n * @private\n * @params {Object} result The ldap result\n * @params {Array} attributes The desired or wanted attributes\n * @returns {Object} A copy of the object with only the requested attributes\n */\nfunction pickAttributes(result, attributes) {\n  if (shouldIncludeAllAttributes(attributes)) {\n    attributes = function() { \n      return(true); \n    };\n  }\n  return(_.pick(result, attributes));\n}\n\n/**\n * Gets all of the groups that the specified distinguishedName (DN) belongs to.\n * \n * @private\n * @param {Object} [opts] Optional LDAP query string parameters to execute. { scope: '', filter: '', attributes: [ '', '', ... ], sizeLimit: 0, timelimit: 0 }\n * @param {String} dn The distinguishedName (DN) to find membership of.\n * @param {Function} callback The callback to execute when completed. callback(err: {Object}, groups: {Array[Group]})\n */\nfunction getGroupMembershipForDN(opts, dn, stack, callback) {\n  var self = this;\n   \n  if (typeof(stack) === 'function') {\n    callback = stack;\n    stack = undefined;\n  }\n  if (typeof(dn) === 'function') {\n    callback = dn;\n    dn = opts;\n    opts = undefined;\n  }\n  if (typeof(opts) === 'string') {\n    stack = dn;\n    dn = opts;\n    opts = undefined;\n  }\n  log.trace('getGroupMembershipForDN(%j,%s,stack:%j)', opts, dn, (stack || []).length);\n\n  // Ensure that a valid DN was provided. Otherwise abort the search.\n  if (! dn) {\n    var error = new Error('No distinguishedName (dn) specified for group membership retrieval.');\n    log.error(error);\n    if (hasEvents('error')) self.emit('error', error);\n    return(callback(error));\n  }\n\n  //  Note: Microsoft provides a 'Transitive Filter' for querying nested groups.\n  //        i.e. (member:1.2.840.113556.1.4.1941:=<userDistinguishedName>)\n  //        However this filter is EXTREMELY slow. Recursively querying ActiveDirectory\n  //        is typically 10x faster.\n  opts = _.defaults(_.omit(opts || {}, 'filter', 'scope', 'attributes'), {\n    filter: '(member='+parseDistinguishedName(dn)+')',\n    scope: 'sub',\n    attributes: joinAttributes((opts || {}).attributes || defaultAttributes.group, [ 'groupType' ])\n  });\n  search.call(self, opts, function(err, results) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    var groups = [];\n    async.forEach(results, function(group, asyncCallback) {\n      // accumulates discovered groups\n      if (typeof(stack) !== 'undefined') {\n        if (!_.findWhere(stack, { cn: group.cn })) {\n          stack.push(new Group(group));\n        } else {\n          // ignore groups already found\n          return(asyncCallback());\n        }\n\n        _.each(stack,function(s) {\n          if (!_.findWhere(groups, { cn: s.cn })) {\n            groups.push(s);\n          }\n        });\n      }\n\n      if (isGroupResult(group)) {\n        log.debug('Adding group \"%s\" to %s\"', group.dn, dn);\n        groups.push(new Group(group));\n\n        // Get the groups that this group may be a member of.\n        log.debug('Retrieving nested group membership for group \"%s\"', group.dn);\n        getGroupMembershipForDN.call(self, opts, group.dn, groups, function(err, nestedGroups) {\n          if (err) {\n            asyncCallback(err);\n            return;\n          }\n\n          nestedGroups = _.map(nestedGroups, function(nestedGroup) {\n            if (isGroupResult(nestedGroup)) {\n              return(new Group(nestedGroup));\n            }\n          });\n          log.debug('Group \"%s\" which is a member of group \"%s\" has %d nested group(s). Nested: %j',\n                    group.dn, dn, nestedGroups.length, _.map(nestedGroups, function(group) {\n                     return(group.dn);\n                   }));\n          Array.prototype.push.apply(groups, nestedGroups);\n          asyncCallback();\n        });\n      }\n      else asyncCallback();\n    }, function(err) {\n       if (err) {\n        callback(err);\n        return;\n      }\n\n      // Remove the duplicates from the list.\n      groups =  _.uniq(_.sortBy(groups, function(group) { return(group.cn || group.dn); }), false, function(group) {\n        return(group.dn);\n      });\n\n      log.info('Group \"%s\" has %d group(s). Groups: %j', dn, groups.length, _.map(groups, function(group) {\n         return(group.dn);\n      }));\n      callback(err, groups);\n    });\n  });\n}\n\n/**\n * For the specified filter, return the distinguishedName (dn) of all the matched entries.\n *\n * @private\n * @param {Object} [opts] Optional LDAP query string parameters to execute. { scope: '', filter: '', attributes: [ '', '', ... ], sizeLimit: 0, timelimit: 0 }\n * @params {Object|String} filter The LDAP filter to execute. Optionally a custom LDAP query object can be specified. { scope: '', filter: '', attributes: [ '', '', ... ], sizeLimit: 0, timelimit: 0 }\n * @param {Function} callback The callback to execute when completed. callback(err: {Object}, dns: {Array[String]})\n */\nfunction getDistinguishedNames(opts, filter, callback) {\n  var self = this;\n\n  if (typeof(filter) === 'function') {\n    callback = filter;\n    filter = opts;\n    opts = undefined;\n  }\n  if (typeof(opts) === 'string') {\n    filter = opts;\n    opts = undefined;\n  }\n  log.trace('getDistinguishedNames(%j,%j)', opts, filter);\n\n  opts = _.defaults(_.omit(opts || {}, 'attributes'), {\n    filter: filter,\n    scope: 'sub',\n    attributes: joinAttributes((opts || {}).attributes || [], [ 'dn' ])\n  });\n  search.call(self, opts, function(err, results) {\n    if (err) {\n      if (callback) callback(err);\n      return;\n    }\n\n    // Extract just the DN from the results\n    var dns =  _.map(results, function(result) {\n      return(result.dn);\n    });\n    log.info('%d distinguishedName(s) found for LDAP query: \"%s\". Results: %j',\n             results.length, truncateLogOutput(opts.filter), results);\n    callback(null, dns);\n  });\n}\n\n/**\n * Gets the distinguished name for the specified user (userPrincipalName/email or sAMAccountName).\n *\n * @private\n * @param {Object} [opts] Optional LDAP query string parameters to execute. { scope: '', filter: '', attributes: [ '', '', ... ], sizeLimit: 0, timelimit: 0 }\n * @param {String} username The name of the username to retrieve the distinguishedName (dn).\n * @param {Function} callback The callback to execute when completed. callback(err: {Object}, dn: {String})\n */\nfunction getUserDistinguishedName(opts, username, callback) {\n  var self = this;\n\n  if (typeof(username) === 'function') {\n    callback = username;\n    username = opts;\n    opts = undefined;\n  }\n  log.trace('getDistinguishedName(%j,%s)', opts, username);\n\n  // Already a dn?\n  if (isDistinguishedName.call(self, username)) {\n    log.debug('\"%s\" is already a distinguishedName. NOT performing query.', username);\n    callback(null, username);\n    return;\n  }\n\n  getDistinguishedNames.call(self, opts, getUserQueryFilter(username), function(err, dns) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    log.info('%d distinguishedName(s) found for user: \"%s\". Returning first dn: \"%s\"',\n             (dns || []).length, username, (dns || [])[0]);\n    callback(null, (dns || [])[0]);\n  });\n}\n\n/**\n * Gets the distinguished name for the specified group (cn).\n *\n * @private\n * @param {Object} [opts] Optional LDAP query string parameters to execute. { scope: '', filter: '', attributes: [ '', '', ... ], sizeLimit: 0, timelimit: 0 }\n * @param {String} groupName The name of the group to retrieve the distinguishedName (dn).\n * @param {Function} callback The callback to execute when completed. callback(err: {Object}, dn: {String})\n */\nfunction getGroupDistinguishedName(opts, groupName, callback) {\n  var self = this;\n\n  if (typeof(groupName) === 'function') {\n    callback = groupName;\n    groupName = opts;\n    opts = undefined;\n  }\n  log.trace('getGroupDistinguishedName(%j,%s)', opts, groupName);\n\n  // Already a dn?\n  if (isDistinguishedName.call(self, groupName)) {\n    log.debug('\"%s\" is already a distinguishedName. NOT performing query.', groupName);\n    callback(null, groupName);\n    return;\n  }\n\n  getDistinguishedNames.call(self, opts, getGroupQueryFilter(groupName), function(err, dns) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    log.info('%d distinguishedName(s) found for group \"%s\". Returning first dn: \"%s\"',\n             (dns || []).length, groupName, (dns || [])[0]);\n    callback(null, (dns || [])[0]);\n  });  \n}\n\n/**\n * Gets the currently configured default attributes\n *\n * @private\n */\nActiveDirectory.prototype._getDefaultAttributes = function _getDefaultAttributes() {\n  return(_.defaults({}, defaultAttributes));\n};\n\n/**\n * Gets the currently configured default user attributes\n *\n * @private\n */\nActiveDirectory.prototype._getDefaultUserAttributes = function _getDefaultUserAttributes() {\n  return(_.defaults({}, (defaultAttributes || {}).user));\n};\n\n/**\n * Gets the currently configured default group attributes\n *\n * @private\n */\nActiveDirectory.prototype._getDefaultGroupAttributes = function _getDefaultGroupAttributes() {\n  return(_.defaults({}, (defaultAttributes || {}).group));\n};\n \n/**\n * For the specified group, retrieve all of the users that belong to the group.\n *\n * @public\n * @param {Object} [opts] Optional LDAP query string parameters to execute. { scope: '', filter: '', attributes: [ '', '', ... ], sizeLimit: 0, timelimit: 0 }\n * @param {String} groupName The name of the group to retrieve membership from.\n * @param {Function} callback The callback to execute when completed. callback(err: {Object}, users: {Array[User]})\n */\nActiveDirectory.prototype.getUsersForGroup = function getUsersForGroup(opts, groupName, callback) {\n  var self = this;\n\n  if (typeof(groupName) === 'function') {\n    callback = groupName;\n    groupName = opts;\n    opts = undefined;\n  }\n  log.trace('getUsersForGroup(%j,%s)', opts, groupName);\n\n  var users = [];\n  var groups = [];\n\n  self.findGroup(_.defaults({}, _.omit(opts || {}, 'attributes'), {\n                   attributes: joinAttributes((opts || {}).attributes || defaultAttributes.group, [ 'member' ])\n                 }), \n                 groupName, function(err, group) {\n    if (err) {\n      if (callback) callback(err);\n      return;\n    }\n\n    // Group not found\n    if (! group) {\n      if (callback) callback(null, group);\n      return;\n    }\n    // If only one result found, encapsulate result into array.\n    if (typeof(group.member) === 'string') {\n      group.member = [ group.member ];\n    }\n\n    /**\n     * Breaks the large array into chucks of the specified size.\n     * @param {Array} arr The array to break into chunks\n     * @param {Number} chunkSize The size of each chunk.\n     * @returns {Array} The resulting array containing each chunk\n     */\n    function chunk(arr, chunkSize) {\n      var result = [];\n      for (var index = 0, length = arr.length; index < length; index += chunkSize) {\n        result.push(arr.slice(index,index + chunkSize));\n      }\n      return(result);\n    }\n\n    // We need to break this into the default size queries so\n    // we can have them running concurrently.\n    var chunks = chunk(group.member || [], defaultPageSize);\n    if (chunks.length > 1) {\n      log.debug('Splitting %d member(s) of \"%s\" into %d parallel chunks',\n                (group.member || []).length, groupName, chunks.length);\n    }\n    var chunksProcessed = 0;\n    async.each(chunks, function getUsersForGroup_ChunkItem(members, asyncChunkCallback) {\n      // We're going to build up a bulk LDAP query so we can reduce\n      // the number of round trips to the server. We need to get\n      // additional details about each 'member' to determine if\n      // it is a group or another user. If it's a group, we need\n      // to recursively retrieve the members of that group.\n      var filter = _.reduce(members || [], function(memo, member, index) {\n        return(memo+'(distinguishedName='+parseDistinguishedName(member)+')');\n      }, '');\n      filter = '(&(|(objectCategory=User)(objectCategory=Group))(|'+filter+'))';\n\n      var localOpts = {\n        filter: filter,\n        scope: 'sub',\n        attributes: joinAttributes((opts || {}).attributes || defaultAttributes.user || [], \n                            getRequiredLdapAttributesForUser(opts), [ 'groupType' ])\n      };\n      search.call(self, localOpts, function onSearch(err, members) {\n        if (err) {\n          asyncChunkCallback(err);\n          return;\n        }\n\n        // Parse the results in parallel.\n        async.forEach(members, function(member, asyncCallback) {\n          // If a user, no groupType will be specified.\n          if (! member.groupType) {\n            var user = new User(pickAttributes(member, (opts || {}).attributes || defaultAttributes.user));\n            self.emit(user);\n            users.push(user);\n            asyncCallback();\n          }\n          else {\n            // We have a group, recursively get the users belonging to this group.\n            self.getUsersForGroup(opts, member.cn, function(err, nestedUsers) {\n              users.push.apply(users, nestedUsers);\n              asyncCallback();\n            });\n          }\n        }, function(err) {\n          if (chunks.length > 1) {\n            log.debug('Finished processing chunk %d/%d', ++chunksProcessed, chunks.length);\n          }\n          asyncChunkCallback(err);\n        });\n      });\n    }, function getUsersForGroup_ChunkComplete(err) {\n      // Remove duplicates\n      users = _.uniq(users, function(user) {\n        return(user.dn || user);\n      });\n      \n\n/*\n      // Remove the dn that was added for duplicate detection if not requested.\n      if (! _.any((opts || {}).attributes || defaultAttributes.user, function(attribute) {\n        return(attribute === 'dn');\n      })) {\n        users = _.each(users, function(user) {\n          delete(users.dn);\n        });\n      }\n*/\n      log.info('%d user(s) belong in the group \"%s\"', users.length, groupName);\n      if (callback) callback(null, users);\n    });\n  });\n};\n\n/**\n * For the specified username, get all of the groups that the user is a member of.\n *\n * @public\n * @param {Object} [opts] Optional LDAP query string parameters to execute. { scope: '', filter: '', attributes: [ '', '', ... ], sizeLimit: 0, timelimit: 0 }\n * @param {String} username The username to retrieve membership information about.\n * @param {Function} [callback] The callback to execute when completed. callback(err: {Object}, groups: {Array[Group]})\n */\nActiveDirectory.prototype.getGroupMembershipForUser = function getGroupMembershipForUser(opts, username, callback) {\n  var self = this;\n\n  if (typeof(username) === 'function') {\n    callback = username;\n    username = opts;\n    opts = undefined;\n  }\n  log.trace('getGroupMembershipForUser(%j,%s)', opts, username);\n\n  getUserDistinguishedName.call(self, opts, username, function(err, dn) {\n    if (err) {\n      if (callback) callback(err);\n      return;\n    }  \n\n    if (! dn) {\n      log.warn('Could not find a distinguishedName for the specified username: \"%s\"', username);\n      if (callback) callback();\n      return;\n    }\n    getGroupMembershipForDN.call(self, opts, dn, function(err, groups) {\n      if (err) {\n        if (callback) callback(err);\n        return;\n      }\n      \n      var results = [];\n      _.each(groups, function(group) {\n        var result = new Group(pickAttributes(group, (opts || {}).attributes || defaultAttributes.group));\n        self.emit(result);\n        results.push(result);\n      });\n      if (callback) callback(err, results);\n    });\n  });\n};\n\n/**\n * For the specified group, get all of the groups that the group is a member of.\n *\n * @public\n * @param {Object} [opts] Optional LDAP query string parameters to execute. { scope: '', filter: '', attributes: [ '', '', ... ], sizeLimit: 0, timelimit: 0 }\n * @param {String} groupName The group to retrieve membership information about.\n * @param {Function} [callback] The callback to execute when completed. callback(err: {Object}, groups: {Array[Group]})\n */\nActiveDirectory.prototype.getGroupMembershipForGroup = function getGroupMembershipForGroup(opts, groupName, callback) {\n  var self = this;\n  \n  if (typeof(groupName) === 'function') {\n    callback = groupName;\n    groupName = opts;\n    opts = undefined;\n  }\n  log.trace('getGroupMembershipForGroup(%j,%s)', opts, groupName);\n\n  getGroupDistinguishedName.call(self, opts, groupName, function(err, dn) {\n    if (err) {\n      if (callback) callback(err);\n      return;\n    }  \n\n    if (! dn) {\n      log.warn('Could not find a distinguishedName for the specified group name: \"%s\"', groupName);\n      if (callback) callback();\n      return;\n    }\n    getGroupMembershipForDN.call(self, opts, dn, function(err, groups) {\n      if (err) {\n        if (callback) callback(err);\n        return;\n      }\n\n      var results = [];\n      _.each(groups, function(group) {\n        var result = new Group(pickAttributes(group, (opts || {}).attributes || defaultAttributes.group));\n        self.emit(result);\n        results.push(result);\n      });\n      if (callback) callback(err, results);\n    });\n  });\n};\n\n/**\n * Checks to see if the specified username exists.\n *\n * @param {Object} [opts] Optional LDAP query string parameters to execute. { scope: '', filter: '', attributes: [ '', '', ... ], sizeLimit: 0, timelimit: 0 }\n * @param {String} username The username to check to see if it exits.\n * @param {Function} callback The callback to execute when completed. callback(err: {Object}, result: {Boolean})\n */ \nActiveDirectory.prototype.userExists = function userExists(opts, username, callback) {\n  var self = this;\n\n  if (typeof(username) === 'function') {\n    callback = username;\n    username = opts;\n    opts = undefined;\n  }\n  log.trace('userExists(%j,%s)', opts, username);\n\n  self.findUser(opts, username, function(err, user) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    log.info('\"%s\" %s exist.', username, (user != null) ? 'DOES' : 'DOES NOT');\n    callback(null, user != null);\n  });\n};\n\n/**\n * Checks to see if the specified group exists.\n *\n * @param {Object} [opts] Optional LDAP query string parameters to execute. { scope: '', filter: '', attributes: [ '', '', ... ], sizeLimit: 0, timelimit: 0 }\n * @param {String} groupName The group to check to see if it exists.\n * @param {Function} callback The callback to execute when completed. callback(err: {Object}, result: {Boolean})\n */ \nActiveDirectory.prototype.groupExists = function groupExists(opts, groupName, callback) {\n  var self = this;\n\n  if (typeof(groupName) === 'function') {\n    callback = groupName;\n    groupName = opts;\n    opts = undefined;\n  }\n  log.trace('groupExists(%j,%s)', opts, groupName);\n\n  self.findGroup(opts, groupName, function(err, result) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    log.info('\"%s\" %s exist.', groupName, (result != null) ? 'DOES' : 'DOES NOT');\n    callback(null, result != null);\n  });\n};\n\n/**\n * Checks to see if the specified user is a member of the specified group.\n *\n * @param {Object} [opts] Optional LDAP query string parameters to execute. { scope: '', filter: '', attributes: [ '', '', ... ], sizeLimit: 0, timelimit: 0 }\n * @param {String} username The username to check for membership.\n * @param {String} groupName The group to check for membership.\n * @param {Function} callback The callback to execute when completed. callback(err: {Object}, result: {Boolean})\n */\nActiveDirectory.prototype.isUserMemberOf = function isUserMemberOf(opts, username, groupName, callback) {\n  var self = this;\n\n  if (typeof(groupName) === 'function') {\n    callback = groupName;\n    groupName = username;\n    username = opts;\n    opts = undefined;\n  }\n  log.trace('isUserMemberOf(%j,%s,%s)', opts, username, groupName);\n\n  opts = _.defaults(_.omit(opts || {}, 'attributes'), {\n    attributes: [ 'cn', 'dn' ] \n  });\n  self.getGroupMembershipForUser(opts, username, function(err, groups) {\n    if (err) {\n      callback(err);\n      return;\n    }\n    if ((! groups) || (groups.length === 0)) {\n      log.info('\"%s\" IS NOT a member of \"%s\". No groups found for user.', username, groupName);\n      callback(null, false);\n      return;\n    }\n\n    // Check to see if the group.distinguishedName or group.cn matches the list of\n    // retrieved groups.\n    var lowerCaseGroupName = (groupName || '').toLowerCase();\n    var result = _.any(groups, function(item) {\n      return(((item.dn || '').toLowerCase() === lowerCaseGroupName) ||\n             ((item.cn || '').toLowerCase() === lowerCaseGroupName));\n     });\n    log.info('\"%s\" %s a member of \"%s\"', username, result ? 'IS' : 'IS NOT', groupName);\n    callback(null, result);\n  });\n};\n\n/**\n * Checks to see if group membership for the specified type is enabled.\n *\n * @param {Object} [opts] The options to inspect. If not specified, uses this.opts.\n * @param {String} name The name of the membership value to inspect. Values: (all|user|group)\n * @returns {Boolean} True if the specified membership is enabled.\n */\nfunction includeGroupMembershipFor(opts, name) {\n  if (typeof(opts) === 'string') {\n    name = opts;\n    opts = this.opts;\n  }\n\n  var lowerCaseName = (name || '').toLowerCase();\n  return(_.any(((opts || this.opts || {}).includeMembership || []), function(i) {\n    i = i.toLowerCase();\n    return((i === 'all') || (i === lowerCaseName));\n  }));\n}\n\n/**\n * Perform a generic search for the specified LDAP query filter. This function will return both\n * groups and users that match the specified filter. Any results not recognized as a user or group\n * (i.e. computer accounts, etc.) can be found in the 'other' attribute / array of the result.\n *\n * @public\n * @param {Object} [opts] Optional LDAP query string parameters to execute. { scope: '', filter: '', attributes: [ '', '', ... ], sizeLimit: 0, timelimit: 0 }. Optionally, if only a string is provided, then the string is assumed to be an LDAP filter.\n * @param {Function} callback The callback to execute when completed. callback(err: {Object}, { users: [ User ], groups: [ Group ], other: [ ] )\n */\nActiveDirectory.prototype.find = function find(opts, callback) {\n  var self = this;\n\n  if (typeof(opts) === 'function') {\n    callback = opts;\n    opts = undefined;\n  }\n  if (typeof(opts) === 'string') {\n    opts = {\n      filter: opts\n    };\n  }\n  log.trace('find(%j)', opts);\n\n  var localOpts = _.defaults(_.omit(opts || {}, 'attributes'), {\n    scope: 'sub',\n    attributes: joinAttributes((opts || {}).attributes || [], defaultAttributes.group || [], defaultAttributes.user || [], \n                        getRequiredLdapAttributesForGroup(opts), getRequiredLdapAttributesForUser(opts), \n                        [ 'objectCategory' ])\n  });\n  search.call(self, localOpts, function onFind(err, results) {\n    if (err) {\n      if (callback) callback(err);\n      return;\n    }\n\n    if ((! results) || (results.length === 0)) {\n      log.warn('No results found for query \"%s\"', truncateLogOutput(localOpts.filter));\n      if (callback) callback();\n      self.emit('done');\n      return;\n    }\n\n    var result = {\n      users: [],\n      groups: [],\n      other: []\n    };\n\n    // Parse the results in parallel.\n    async.forEach(results, function(item, asyncCallback) {\n      if (isGroupResult(item)) {\n        var group = new Group(pickAttributes(item, (opts || {}).attributes || defaultAttributes.group));\n        result.groups.push(group);\n        // Also retrieving user group memberships?\n        if (includeGroupMembershipFor(opts, 'group')) {\n          getGroupMembershipForDN.call(self, opts, group.dn, function(err, groups) {\n            if (err) return(asyncCallback(err));\n\n            group.groups = groups;\n            self.emit('group', group);\n            asyncCallback();\n          });\n        } else {\n          self.emit('group', group);\n          asyncCallback();\n        }\n      }\n      else if (isUserResult(item)) {\n        var user = new User(pickAttributes(item, (opts || {}).attributes || defaultAttributes.user));\n        result.users.push(user);\n        // Also retrieving user group memberships?\n        if (includeGroupMembershipFor(opts, 'user')) {\n          getGroupMembershipForDN.call(self, opts, user.dn, function(err, groups) {\n            if (err) return(asyncCallback(err));\n\n            user.groups = groups;\n            self.emit('user', user);\n            asyncCallback();\n          });\n        } else {\n          self.emit('user', user);\n          asyncCallback();\n        }\n      }\n      else {\n        var other = pickAttributes(item, (opts || {}).attributes || _.union(defaultAttributes.user, defaultAttributes.group));\n        result.other.push(other);\n        self.emit('other', other);\n        asyncCallback();\n      }\n\n    }, function(err) {\n      if (err) {\n        if (callback) callback(err);\n        return;\n      }\n\n      log.info('%d group(s), %d user(s), %d other found for query \"%s\". Results: %j',\n               result.groups.length, result.users.length, result.other.length,\n               truncateLogOutput(opts.filter), result);\n      self.emit('groups', result.groups);\n      self.emit('users', result.users);\n\n      if (callback) callback(null, result);\n    });\n  });\n};\n\n/**\n * Perform a generic search on the Deleted Objects container for active directory. For this function\n * to work correctly, the tombstone feature for active directory must be enabled. A tombstoned object\n * has most of the attributes stripped from the object.\n *\n * @public\n * @param {Object} [opts] Optional LDAP query string parameters to execute. { scope: '', filter: '', attributes: [ '', '', ... ], sizeLimit: 0, timelimit: 0 }. Optionally, if only a string is provided, then the string is assumed to be an LDAP filter.\n * @param {Function} callback The callback to execute when completed. callback(err: {Object}, result: [ ])\n */\nActiveDirectory.prototype.findDeletedObjects = function find(opts, callback) {\n  var self = this;\n\n  if (typeof(opts) === 'function') {\n    callback = opts;\n    opts = undefined;\n  }\n  if (typeof(opts) === 'string') {\n    opts = {\n      filter: opts\n    };\n  }\n  log.trace('findDeletedObjects(%j)', opts);\n\n  var defaultDeletedAttributes = [\n    'attributeID', 'attributeSyntax', 'dnReferenceUpdate' , 'dNSHostName' , 'flatName',\n    'governsID', 'groupType', 'instanceType', 'lDAPDisplayName', 'legacyExchangeDN',\n    'mS-DS-CreatorSID', 'mSMQOwnerID', 'nCName', 'objectClass', 'objectGUID', 'objectSid',\n    'oMSyntax', 'proxiedObjectName', 'replPropertyMetaData', 'sAMAccountName', 'securityIdentifier',\n    'sIDHistory', 'subClassOf', 'systemFlags', 'trustPartner', 'trustDirection', 'trustType',\n    'trustAttributes', 'userAccountControl', 'uSNChanged', 'uSNCreated', 'whenCreated',\n    'msDS-AdditionalSamAccountName', 'msDS-Auxiliary-Classes', 'msDS-Entry-Time-To-Die',\n    'msDS-IntId', 'msSFU30NisDomain', 'nTSecurityDescriptor', 'uid' \n  ];\n\n  /**\n   * Performs the actul search of the specified baseDN for any deleted (tombstoned) objects.\n   * @param {String} baseDN The baseDN to search on.\n   * @param {Object} opts The ldapjs query options.\n   */\n  function searchDeletedObjects(baseDN, opts) {\n    search.call(self, baseDN, _.defaults({}, opts, { includeDeleted: true }), function onFind(err, results) {\n      if (err) {\n        if (callback) callback(err);\n        return;\n      }\n\n      if ((! results) || (results.length === 0)) {\n        log.warn('No deleted objects found for query \"%s\"', truncateLogOutput(opts.filter));\n        if (callback) callback();\n        self.emit('done');\n        return;\n      }\n\n      var deletedItems = [];\n\n      // Parse the results in parallel.\n      _.forEach(deletedItemss, function(item) {\n        var deletedItem = pickAttributes(item, (opts | {}).attributes || []);\n        self.emit('entry:deleted', deletedItem);\n        deletedItems.push(deletedItem);\n      });\n\n      log.info('%d deleted objects found for query \"%s\". Results: %j',\n               deletedItems.length, truncateLogOutput(localOpts.filter), deletedItems);\n      self.emit('deleted', deletedItems);\n      if (callback) callback(null, deletedItems);\n    });\n  }\n\n  var localOpts = _.defaults(opts || {}, {\n    scope: 'one',\n    attributes: joinAttributes((opts || {}).attributes || [], defaultDeletedAttributes),\n    controls: [ ]\n  });\n  // Get the BaseDN for the tree\n  if (! localOpts.baseDN) {\n    log.debug('No baseDN specified for Deleted Object. Querying RootDSE at %s.', self.opts.url);\n    ActiveDirectory.prototype.getRootDSE(self.opts.url, [ 'defaultNamingContext' ], function(err, result) {\n      if (err) {\n        if (callback) callback(err);\n        return;\n      }\n\n      log.info('Retrieved defaultNamingContext (%s) from RootDSE at %s.', result.defaultNamingContext, self.opts.url);\n      searchDeletedObjects('CN=Deleted Objects,' + result.defaultNamingContext, localOpts);\n    });\n  }\n  else searchDeletedObjects(localOpts.baseDN, localOpts);\n};\n\n/**\n * Retrieves the specified group.\n *\n * @public\n * @param {Object} [opts] Optional LDAP query string parameters to execute. { scope: '', filter: '', attributes: [ '', '', ... ], sizeLimit: 0, timelimit: 0 }\n * @param {String} groupName The group (cn) to retrieve information about. Optionally can pass in the distinguishedName (dn) of the group to retrieve.\n * @param {Function} callback The callback to execute when completed. callback(err: {Object}, group: {Group})\n */\nActiveDirectory.prototype.findGroup = function findGroup(opts, groupName, callback) {\n  var self = this;\n\n  if (typeof(groupName) === 'function') {\n    callback = groupName;\n    groupName = opts;\n    opts = undefined;\n  }\n  if (typeof(opts) === 'string') {\n    groupName = opts;\n    opts = undefined;\n  }\n  log.trace('findGroup(%j,%s)', opts, groupName);\n\n  var localOpts = _.defaults(_.omit(opts || {}, 'attributes'), {\n    filter: getGroupQueryFilter.call(self, groupName),\n    scope: 'sub',\n    attributes: joinAttributes((opts || {}).attributes || defaultAttributes.group, getRequiredLdapAttributesForGroup(opts))\n  });\n  search.call(self, localOpts, function onSearch(err, results) {\n    if (err) {\n      if (callback) callback(err);\n      return;\n    }\n\n    if ((! results) || (results.length === 0)) {\n      log.warn('Group \"%s\" not found for query \"%s\"', groupName, truncateLogOutput(localOpts.filter));\n      if (callback) callback();\n      return;\n    }\n\n    var group = new Group(pickAttributes(results[0], (opts || {}).attributes || defaultAttributes.group));\n    log.info('%d group(s) found for query \"%s\". Returning first group: %j',\n             results.length, truncateLogOutput(localOpts.filter), group);\n    // Also retrieving user group memberships?\n    if (includeGroupMembershipFor(opts, 'group')) {\n      getGroupMembershipForDN.call(self, opts, group.dn, function(err, groups) {\n        if (err) {\n          if (callback) callback(err);\n          return;\n        }\n\n        group.groups = groups;\n        self.emit('group', group);\n        if (callback) callback(err, group);\n      });\n    }\n    else {\n      self.emit('group', group);\n      if (callback) callback(err, group);\n    }\n  });\n};\n\n/**\n * Perform a generic search for groups that match the specified filter. The default LDAP filter for groups is\n * specified as (&(objectClass=group)(!(objectClass=computer))(!(objectClass=user))(!(objectClass=person)))\n *\n * @public\n * @param {Object} [opts] Optional LDAP query string parameters to execute. { scope: '', filter: '', attributes: [ '', '', ... ], sizeLimit: 0, timelimit: 0 }. Optionally, if only a string is provided, then the string is assumed to be an LDAP filter that will be appended as the last parameter in the default LDAP filter.\n * @param {Function} callback The callback to execute when completed. callback(err: {Object}, groups: [ Group ])\n */\nActiveDirectory.prototype.findGroups = function findGroup(opts, callback) {\n  var self = this;\n  var defaultGroupFilter = '(objectClass=group)(!(objectClass=computer))(!(objectClass=user))(!(objectClass=person))';\n\n  if (typeof(opts) === 'function') {\n    callback = opts;\n    opts = '';\n  }\n  if ((typeof(opts) === 'string') && (opts)) {\n    opts = {\n      filter: '(&'+defaultGroupFilter+getCompoundFilter(opts)+')'\n    };\n  }\n\n  log.trace('findGroups(%j)', opts);\n\n  var localOpts = _.defaults(_.omit(opts || {}, 'attributes'), {\n    filter: '(&'+defaultGroupFilter+')',\n    scope: 'sub',\n    attributes: joinAttributes((opts || {}).attributes || defaultAttributes.group || [], getRequiredLdapAttributesForGroup(opts), \n                        [ 'groupType' ])\n  });\n  search.call(self, localOpts, function onSearch(err, results) {\n    if (err) {\n      if (callback) callback(err);\n      return;\n    }\n\n    if ((! results) || (results.length === 0)) {\n      log.warn('No groups found matching query \"%s\"', truncateLogOutput(localOpts.filter));\n      if (callback) callback();\n      return;\n    }\n\n    var groups = [];\n\n    // Parse the results in parallel.\n    async.forEach(results, function(result, asyncCallback) {\n      if (isGroupResult(result)) {\n        var group = new Group(pickAttributes(result, (opts || {}).attributes || defaultAttributes.user));\n        groups.push(group);\n\n        // Also retrieving user group memberships?\n        if (includeGroupMembershipFor(opts, 'group')) {\n          getGroupMembershipForDN.call(self, opts, group.dn, function(err, groups) {\n            if (err) return(asyncCallback(err));\n  \n            group.groups = groups;\n            self.emit('group', group);\n            asyncCallback();\n          });\n        }\n        else {\n          self.emit('group', group);\n          asyncCallback();\n        }\n      }\n      else asyncCallback();\n    }, function(err) {\n      if (err) {\n        if (callback) callback(err);\n        return;\n      }\n\n      log.info('%d group(s) found for query \"%s\". Groups: %j', groups.length, truncateLogOutput(localOpts.filter), groups);\n      self.emit('groups', groups);\n      if (callback) callback(null, groups);\n    });\n  });\n};\n\n/**\n * Retrieves the specified user.\n *\n * @public\n * @param {Object} [opts] Optional LDAP query string parameters to execute. { scope: '', filter: '', attributes: [ '', '', ... ], sizeLimit: 0, timelimit: 0 }\n * @param {String} username The username to retrieve information about. Optionally can pass in the distinguishedName (dn) of the user to retrieve.\n * @param {Boolean} [includeMembership] OBSOLETE; NOT NOT USE. Indicates if the results should include group memberships for the user. Defaults to false.\n * @param {Function} callback The callback to execute when completed. callback(err: {Object}, user: {User})\n */\nActiveDirectory.prototype.findUser = function findUser(opts, username, includeMembership, callback) {\n  var self = this;\n\n  if (typeof(includeMembership) === 'function') {\n    callback = includeMembership;\n    includeMembership = undefined;\n  }\n  if (typeof(username) === 'function') {\n    callback = username;\n    username = opts;\n    opts = undefined;\n  }\n  if (typeof(username) === 'boolean') {\n    includeMembership = username;\n    username = opts;\n  }\n  if (typeof(opts) === 'string') {\n    username = opts;\n    opts = undefined;\n  }\n  log.trace('findUser(%j,%s,%s)', opts, username, includeMembership);\n\n  var localOpts = _.defaults(_.omit(opts || {}, 'attributes'), {\n    filter: getUserQueryFilter.call(self, username),\n    scope: 'sub',\n    attributes: joinAttributes((opts || {}).attributes || defaultAttributes.user || [], getRequiredLdapAttributesForUser(opts))\n  });\n  search.call(self, localOpts, function onSearch(err, results) {\n    if (err) {\n      if (callback) callback(err);\n      return;\n    }\n\n    if ((! results) || (results.length === 0)) {\n      log.warn('User \"%s\" not found for query \"%s\"', username, truncateLogOutput(localOpts.filter));\n      if (callback) callback();\n      return;\n    }\n\n    var user = new User(pickAttributes(results[0], (opts || {}).attributes || defaultAttributes.user));\n    log.info('%d user(s) found for query \"%s\". Returning first user: %j', results.length, truncateLogOutput(localOpts.filter), user);\n\n    // Also retrieving user group memberships?\n    if (includeGroupMembershipFor(opts, 'user') || includeMembership) {\n      getGroupMembershipForDN.call(self, opts, user.dn, function(err, groups) {\n        if (err) {\n          if (callback) callback(err);\n          return;\n        }\n\n        user.groups = groups;\n        self.emit('user', user);\n        if (callback) callback(err, user);\n      });\n    }\n    else {\n      self.emit('user', user);\n      if (callback) callback(err, user);\n    }\n  });\n};\n\n/**\n * Perform a generic search for users that match the specified filter. The default LDAP filter for users is\n * specified as (&(|(objectClass=user)(objectClass=person))(!(objectClass=computer))(!(objectClass=group)))\n *\n * @public\n * @param {Object} [opts] Optional LDAP query string parameters to execute. { scope: '', filter: '', attributes: [ '', '', ... ], sizeLimit: 0, timelimit: 0 }. Optionally, if only a string is provided, then the string is assumed to be an LDAP filter that will be appended as the last parameter in the default LDAP filter.\n * @param {Boolean} [includeMembership] OBSOLETE; NOT NOT USE. Indicates if the results should include group memberships for the user. Defaults to false.\n * @param {Function} callback The callback to execute when completed. callback(err: {Object}, users: [ User ])\n */\nActiveDirectory.prototype.findUsers = function findUsers(opts, includeMembership, callback) {\n  var self = this;\n  var defaultUserFilter = '(|(objectClass=user)(objectClass=person))(!(objectClass=computer))(!(objectClass=group))';\n\n  if (typeof(includeMembership) === 'function') {\n    callback = includeMembership;\n    includeMembership = false;\n  }\n  if (typeof(opts) === 'function') {\n    callback = opts;\n    opts = '';\n  }\n  if ((typeof(opts) === 'string') && (opts)) {\n    opts = {\n      filter: '(&'+defaultUserFilter+getCompoundFilter(opts)+')'\n    };\n  }\n  log.trace('findUsers(%j,%s)', opts, includeMembership);\n\n  var localOpts = _.defaults(_.omit(opts || {}, 'attributes'), {\n    filter: '(&'+defaultUserFilter+')',\n    scope: 'sub',\n    attributes: joinAttributes((opts || {}).attributes || defaultAttributes.user || [], \n                               getRequiredLdapAttributesForUser(opts), [ 'objectCategory' ])\n  });\n  search.call(self, localOpts, function onSearch(err, results) {\n    if (err) {\n      if (callback) callback(err);\n      return;\n    }\n\n    if ((! results) || (results.length === 0)) {\n      log.warn('No users found matching query \"%s\"', truncateLogOutput(localOpts.filter));\n      if (callback) callback();\n      return;\n    }\n\n    var users = [];\n\n    // Parse the results in parallel.\n    async.forEach(results, function(result, asyncCallback) {\n      if (isUserResult(result)) {\n        var user = new User(pickAttributes(result, (opts || {}).attributes || defaultAttributes.user));\n        users.push(user);\n\n        // Also retrieving user group memberships?\n        if (includeGroupMembershipFor(opts, 'user') || includeMembership) {\n          getGroupMembershipForDN.call(self, opts, user.dn, function(err, groups) {\n            if (err) return(asyncCallback(err));\n  \n            user.groups = groups;\n            self.emit('user', user);\n            asyncCallback();\n          });\n        }\n        else {\n          self.emit('user', user);\n          asyncCallback();\n        }\n      }\n      else asyncCallback();\n    }, function(err) {\n      if (err) {\n        if (callback) callback(err);\n        return;\n      }\n\n      log.info('%d user(s) found for query \"%s\". Users: %j', users.length, truncateLogOutput(opts.filter), users);\n      self.emit('users', users);\n      if (callback) callback(null, users);\n    });\n  });\n};\n\n/**\n * Attempts to authenticate the specified username / password combination.\n *\n * @public\n * @param {String} username The username to authenticate.\n * @param {String} password The password to use for authentication.\t\n * @param {Function} callback The callback to execute when the authenication is completed. callback(err: {Object}, authenticated: {Boolean})\n */\nActiveDirectory.prototype.authenticate = function authenticate(username, password, callback) {\n  var self = this;\n  log.trace('authenticate(%j,%s)', username, isPasswordLoggingEnabled ? password : '********');\n\n  // Skip authentication if an empty username or password is provided.\n  if ((! username) || (! password)) {\n    var err = {\n      'code': 0x31,\n      'errno': 'LDAP_INVALID_CREDENTIALS',\n      'description': 'The supplied credential is invalid'\n    };\n    return(callback(err, false));\n  }\n\n  var errorHandled = false;\n  function handleError(err) {\n    if (! errorHandled) {\n      errorHandled = true;\n      if (hasEvents.call(self, 'error')) self.emit('error', err);\n      return(callback(err, false));\n    }\n  }\n\n  var client = createClient.call(self);\n  client.on('error', handleError);\n  client.bind(username, password, function(err) {\n    client.unbind();\n    var message = util.format('Authentication %s for \"%s\" as \"%s\" (password: \"%s\")',\n                              err ? 'failed' : 'succeeded',\n                              self.opts.url, username, isPasswordLoggingEnabled ? password : '********');\n    if (err) {\n      log.warn('%s. Error: %s', message, err);\n      return(handleError(err));\n    }\n\n    log.info(message);\n    return(callback(err, true));\n  });\n};\n\n/**\n * Retrieves the root DSE for the specified url\n *\n * @public\n * @param {String} url The url to retrieve the root DSE for.\n * @param {Array} [attributes] The optional list of attributes to retrieve. Returns all if not specified.\n * @param {Function} callback The callback to execute when the getRootDSE is completed. callback(err: {Object}, result: {Object})\n */\nActiveDirectory.prototype.getRootDSE = function getRootDSE(url, attributes, callback) {\n  var self = this;\n  if (typeof(attributes) === 'function') {\n    callback = attributes;\n    attributes = undefined;\n  }\n  if (typeof(url) === 'function') {\n    callback = url;\n    url = self.url || self.opts.url;\n    attributes = undefined;\n  }\n  if (! url) throw new Error('No url specified for the root DSE. Please specify an ldap url in the following format: \"ldap://yourdomain.com:389\".');\n  log.trace('getRootDSE(%s,%j)', url, attributes || [ '*' ]);\n\n  /**\n   * Inline function handle connection and result errors.\n   *\n   * @private\n   **/\n  function onClientError(err) {\n    // Ignore ECONNRESET errors\n    if ((err || {}).errno !== 'ECONNRESET') {\n      log.error('An unhandled error occured when searching for the root DSE at \"%s\". Error: %j', url, err);\n      if (hasEvents.call(self, 'error')) self.emit('error', err)\n    }\n  }\n\n  var client = createClient.call(this, url);\n  client.on('error', onClientError);\n  // Anonymous bind\n  client.bind('', '', function(err) {\n    if (err) {\n      log.error('Anonymous bind to \"%s\" failed. Error: %s', url, err);\n      return(callback(err, false));\n    }\n\n    client.search('', { scope: 'base', attributes: attributes || [ '*' ], filter: '(objectClass=*)' }, function(err, result) {\n      if (err) {\n        log.error('Root DSE search failed for \"%s\". Error: %s', url, err);\n        return(callback(err));\n      }\n\n      result.on('error', onClientError);\n      result.on('end', function(result) {\n        client.unbind();\n      });\n      result.on('searchEntry', function(entry) {\n        callback(null, _.omit(entry.object, 'controls'));\n      });\n    });    \n  });\n};\n\nmodule.exports = ActiveDirectory;\n","/home/travis/build/npmtest/node-npmtest-activedirectory/node_modules/activedirectory/lib/models/user.js":"var _ = require('underscore');\n\n/** \n * Represents an ActiveDirectory user account.\n *\n * @private\n * @param {Object} [properties] The properties to assign to the newly created item.\n * @returns {User}\n */\nvar User = function(properties) {\n  if (this instanceof User) {\n    for (var property in (properties || {})) {\n      if (Array.prototype.hasOwnProperty.call(properties, property)) {\n        this[property] = properties[property];\n      }\n    }\n  }\n  else {\n   return(new User(properties));\n  }\n};\n\n/**\n * Checks to see if the user is the member of the specified group.\n *\n * @param {String} group The name of the group to check for membership.\n * @returns {Boolean}\n */\nUser.prototype.isMemberOf = function isMemberOf(group) {\n  if (! group) return(false);\n\n  group = (group || '').toLowerCase();\n  return(_.any(this.groups || [], function(item) {\n    return (((item || {}).cn || '').toLowerCase() === group);\n  }));\n};\n\nmodule.exports = User;\n","/home/travis/build/npmtest/node-npmtest-activedirectory/node_modules/activedirectory/lib/models/group.js":"/** \n * Represents an ActiveDirectory group\n *\n * @private\n * @param {Object} [properties] The properties to assign to the newly created item.\n * @returns {Group}\n */\nvar Group = function(properties) {\n  if (this instanceof Group) {\n    for (var property in (properties || {})) {\n      if (Array.prototype.hasOwnProperty.call(properties, property)) {\n        this[property] = properties[property];\n      }\n    }\n  }\n  else {\n    return(new Group(properties));\n  }\n};\n\nmodule.exports = Group;\n","/home/travis/build/npmtest/node-npmtest-activedirectory/node_modules/activedirectory/lib/client/rangeretrievalspecifierattribute.js":"var _ = require('underscore');\n\n// [attribute];range=[low]-[high]\n// matching: 1 = name, 2 = low, 3 = high\nvar pattern = '^([^;]+);range=(\\\\d+)-(.+)?$'; \n\n/**\n * Parses the range retrieval specifier into an object.\n * \n * @private\n * @param {String} range The range retrieval specifier to parse.\n * @returns {RangeRetrievalSpecifier}\n */\nfunction parseRangeRetrievalSpecifierAttribute(attribute) {\n  var re = new RegExp(pattern, 'i');\n  var match = re.exec(attribute);\n  return({\n    attributeName: match[1],\n    low: parseInt(match[2]),\n    high: parseInt(match[3]) || null\n  });\n};\n\n/**\n * Multi-valued attribute range retreival specifier.\n *\n * @private\n * @constructor\n * @param {String|Object} attribute The actual attribute name. May also contain a full range retrieval specifier for parsing. (i.e. [attribute];range=[low]-[high]). Optionally an object can be specified.\n * @returns {RangeRetrievalSpecifierAttribute}\n */\nvar RangeRetrievalSpecifierAttribute = function(attribute) {\n  if (this instanceof RangeRetrievalSpecifierAttribute) {\n    if (! attribute) throw new Error('No attribute provided to create a range retrieval specifier.');\n    if (typeof(attribute) === 'string') {\n      attribute = parseRangeRetrievalSpecifierAttribute(attribute);\n    }\n\n    for(var property in attribute) {\n      if (Array.prototype.hasOwnProperty.call(attribute, property)) {\n        this[property] = attribute[property];\n      }\n    }\n  }\n  else {\n    return(new RangeRetrievalSpecifierAttribute(attribute));\n  }\n}\n\n/** \n * Gets the next range retrieval specifier for a query.\n *\n * @private\n * @returns {String}\n */\nRangeRetrievalSpecifierAttribute.prototype.next = function next() {\n  var self = this;\n\n  if ((self.high != null) && (self.high != self.low)) {\n    var low = self.low;\n    var high = self.high;\n\n    self.low = high + 1;\n    self.high = high + (high - low) + 1;\n    return(this);\n  }\n  return(null);\n}\n\n/** \n * Checks to see if the range specifier has been exhausted or completed.\n *\n * @private\n * @returns {Boolean}\n */\nRangeRetrievalSpecifierAttribute.prototype.isComplete = function isComplete() {\n  var self = this;\n  return((self.high == null) || (typeof(self.high) === 'undefined'));\n}\n\n/** \n * Gets the string representation of the range retrieval specifier.\n *\n * @private\n * @returns {String}\n */\nRangeRetrievalSpecifierAttribute.prototype.toString = function toString() {\n  var self = this;\n\n  return(self.attributeName + ';range=' + self.low + '-' + (self.high ? self.high : '*'));\n}\n\n/**\n * Retrieves all of the attributes which have range attributes specified.\n * \n * @private\n * @static\n * @param {Object} item The value to extract the range retrieval attributes from.\n * @returns {Array[RangeRetrievalSpecifierAttribute]}\n */\nRangeRetrievalSpecifierAttribute.prototype.getRangeAttributes = function getRangeAttributes(item) {\n  var attributes = [];\n  for(var attribute in (item || {})) {\n    if (RangeRetrievalSpecifierAttribute.prototype.isRangeAttribute(attribute)) {\n      var range = new RangeRetrievalSpecifierAttribute(attribute);\n      attributes.push(range);\n    }\n  }\n  return(attributes.length > 0 ? attributes : null);\n};\n\n/**\n * Checks to see if the specified attribute is a range retrieval attribute.\n * \n * @private\n * @static\n * @param {String} attribute The attribute to inspect.\n * @returns {Boolean}\n */\nRangeRetrievalSpecifierAttribute.prototype.isRangeAttribute = function isRangeAttribute(attribute) {\n  var re = new RegExp(pattern, 'i');\n  return(re.test(attribute));\n};\n\n/**\n * Checks to see if the specified object has any range retrieval attributes.\n * \n * @private\n * @static\n * @param {Object} item The value to check for range retrieval specifiers.\n * @returns {Boolean}\n */\nRangeRetrievalSpecifierAttribute.prototype.hasRangeAttributes = function hasRangeAttributes(item) {\n  return(_.any(_.keys(item || {}), function(attribute) {\n    return(RangeRetrievalSpecifierAttribute.prototype.isRangeAttribute(attribute));\n  }));\n};\n\nmodule.exports = RangeRetrievalSpecifierAttribute;\n"}